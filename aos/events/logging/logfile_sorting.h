#ifndef AOS_EVENTS_LOGGING_LOGFILE_SORTING_H_
#define AOS_EVENTS_LOGGING_LOGFILE_SORTING_H_

#include <iostream>
#include <map>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>

#include "aos/configuration.h"
#include "aos/events/logging/log_backend.h"
#include "aos/time/time.h"
#include "aos/uuid.h"

namespace aos {
namespace logger {

struct Boots {
  // Maps the boot UUID to the boot count.  Since boot UUIDs are unique, we
  // don't need to be node specific and can do this for all nodes.
  std::map<std::string, int> boot_count_map;

  // Maps the node index to a set of all boots for that node.
  std::vector<std::vector<std::string>> boots;

  // TODO(austin): Aggregated start time should live here.  This is a property
  // of sorting!
};

// Datastructure to hold ordered parts.
struct LogParts {
  // Monotonic and realtime start times for this set of log files.  For log
  // files which started out unknown and then became known, this is the known
  // start time.
  aos::monotonic_clock::time_point monotonic_start_time;
  aos::realtime_clock::time_point realtime_start_time;

  // Time on the logger node (if applicable) that this log file started.
  aos::monotonic_clock::time_point logger_monotonic_start_time =
      aos::monotonic_clock::min_time;
  aos::realtime_clock::time_point logger_realtime_start_time =
      aos::realtime_clock::min_time;

  // All log files and parts from a single logging event will have
  // the same uuid.  This should be all the files generated on a single node.
  // Used to correlate files recorded together.
  std::string log_event_uuid;
  // All the parts which go together have the same uuid.
  std::string parts_uuid;
  // All log parts generated by a single Logger instance will have the same
  // value here.
  std::string logger_instance_uuid;
  // All log events across all nodes produced by a single high-level start event
  // will have the same value here.
  std::string log_start_uuid;

  // The node this represents, or empty if we are in a single node world.
  std::string node;

  // Boot UUID of the node which generated this data, if available.  For local
  // data and timestamps, this is the same as the logger_boot_uuid.  For remote
  // data, this is the boot_uuid of the remote node.
  std::string source_boot_uuid;

  // Boot number for this node.  This communicates the order of all the
  // source_boot_uuid's for a node.
  size_t boot_count = 0;

  // Boot number for the node where this data was logged.
  // This is theoretically redundant with LogFile, except that we quickly end up
  // using LogParts without the corresponding LogFile datastructure.
  size_t logger_boot_count = 0;

  // Pre-sorted list of parts.
  std::vector<std::string> parts;

  // Configuration for all the log parts.  This will be a single object for all
  // log files with the same config.
  std::string config_sha256;
  std::shared_ptr<const aos::Configuration> config;

  // Information about all the boots that the system has observed.
  std::shared_ptr<const Boots> boots;
};

// Datastructure to hold parts from the same run of the logger which have no
// ordering constraints relative to each other.
struct LogFile {
  // All log files and parts from a single logging event will have
  // the same uuid.  This should be all the files generated on a single node.
  // Used to correlate files recorded together.
  std::string log_event_uuid;
  // All log parts generated by a single Logger instance will have the same
  // value here.
  std::string logger_instance_uuid;
  // All log events across all nodes produced by a single high-level start event
  // will have the same value here.
  std::string log_start_uuid;

  // The node the logger was running on (if available)
  std::string logger_node;
  // Boot UUID of the node running the logger.
  std::string logger_boot_uuid;

  // Boot number for the logger node.
  size_t logger_boot_count = 0;

  // The start time on the logger node.
  aos::monotonic_clock::time_point monotonic_start_time;
  aos::realtime_clock::time_point realtime_start_time;

  // The name field in the log file headers.
  std::string name;

  // The logger version info in the logfile headers, if available.
  std::string logger_sha1;
  std::string logger_version;

  // All the parts, unsorted.
  std::vector<LogParts> parts;

  // A list of parts which were corrupted and are unknown where they should go.
  std::vector<std::string> corrupted;

  // Configuration for all the log parts and files.  This will be a single
  // object for log files with the same config.
  std::string config_sha256;
  std::shared_ptr<const aos::Configuration> config;
  std::shared_ptr<const Boots> boots;
};

std::ostream &operator<<(std::ostream &stream, const LogFile &file);
std::ostream &operator<<(std::ostream &stream, const LogParts &parts);

// Takes a bunch of parts and sorts them based on part_uuid and part_index.
std::vector<LogFile> SortParts(const std::vector<std::string> &parts);

// Sort parts of a single log.
std::vector<LogFile> SortParts(const LogSource &log_source);

// Recursively searches the file/folder for .bfbs and .bfbs.xz files and adds
// them to the vector.
void FindLogs(std::vector<std::string> *files, std::string filename);

// Recursively searches the file/folder for .bfbs and .bfbs.xz files and returns
// them in a vector.
std::vector<std::string> FindLogs(std::string filename);

// Recursively searches for logfiles in argv[1] and onward.
std::vector<std::string> FindLogs(int argc, char **argv);

// Validates that collection of log files or log parts shares the same configs.
template <typename TCollection>
bool CheckMatchingConfigs(const TCollection &items) {
  const Configuration *config = nullptr;
  for (const auto &item : items) {
    VLOG(1) << item;
    if (config == nullptr) {
      config = item.config.get();
    } else {
      if (config != item.config.get()) {
        LOG(ERROR) << ": Config mismatched: " << config << " vs. "
                   << item.config.get();
        return false;
      }
    }
  }
  if (config == nullptr) {
    LOG(ERROR) << ": No configs are found";
    return false;
  }
  return true;
}

// Collection of log parts that associated with pair: node and boot.
class SelectedLogParts {
 public:
  SelectedLogParts(std::optional<const LogSource *> log_source,
                   std::string_view node_name, size_t boot_count,
                   std::vector<LogParts> log_parts)
      : log_source_(log_source),
        node_name_(node_name),
        boot_count_(boot_count),
        log_parts_(std::move(log_parts)) {
    CHECK_GT(log_parts_.size(), 0u) << ": Nothing was selected for node "
                                    << node_name << " boot " << boot_count;
    configs_matched_ = CheckMatchingConfigs(log_parts_);

    // Enforce that we are sorting things only from a single node from a single
    // boot.
    const std::string_view part0_source_boot_uuid =
        log_parts_.front().source_boot_uuid;
    for (const auto &part : log_parts_) {
      CHECK_EQ(node_name_, part.node) << ": Can't merge different nodes.";
      CHECK_EQ(part0_source_boot_uuid, part.source_boot_uuid)
          << ": Can't merge different boots.";
      CHECK_EQ(boot_count_, part.boot_count);
    }
  }

  // Use items in fancy loops.
  auto begin() { return log_parts_.begin(); }
  auto end() { return log_parts_.end(); }
  auto cbegin() const { return log_parts_.cbegin(); }
  auto cend() const { return log_parts_.cend(); }
  auto begin() const { return log_parts_.begin(); }
  auto end() const { return log_parts_.end(); }

  const Configuration *config() const {
    // TODO (Alexei): it is a first usage of assumption that all parts have
    // matching configs. Should it be strong requirement and validated in the
    // constructor?
    CHECK(configs_matched_);
    return log_parts_.front().config.get();
  }

  const std::string &node_name() const { return node_name_; }

  // Number of boots found in the log parts.
  size_t boot_count() const { return boot_count_; }

 private:
  std::optional<const LogSource *> log_source_;
  std::string node_name_;
  size_t boot_count_;
  std::vector<LogParts> log_parts_;

  // Indicates that all parts shared the same config.
  bool configs_matched_;
};

// Container that keeps a sorted list of log files and provides functions that
// commonly used during log reading.
class LogFilesContainer {
 public:
  // Initializes log file container with the list of sorted files (results of
  // SortParts).
  explicit LogFilesContainer(std::vector<LogFile> log_files)
      : LogFilesContainer(std::nullopt, std::move(log_files)) {}

  // Sorts and initializes log container with files from an abstract log source.
  explicit LogFilesContainer(const LogSource *log_source)
      : LogFilesContainer(log_source, SortParts(*log_source)) {}

  // Returns true when at least on of the log files associated with node.
  bool ContainsPartsForNode(std::string_view node_name) const {
    // TODO (Alexei): Implement
    // https://en.cppreference.com/w/cpp/container/unordered_map/find with C++20
    return nodes_boots_.count(std::string(node_name)) > 0;
  }

  // Returns numbers of reboots found in log files associated with the node.
  size_t BootsForNode(std::string_view node_name) const {
    const auto &node_item = nodes_boots_.find(std::string(node_name));
    CHECK(node_item != nodes_boots_.end())
        << ": Missing parts associated with node " << node_name;
    CHECK_GT(node_item->second, 0u) << ": No boots for node " << node_name;
    return node_item->second;
  }

  // Get only log parts that associated with node and boot number.
  SelectedLogParts SelectParts(std::string_view node_name,
                               size_t boot_count) const {
    std::vector<LogParts> result;
    for (const LogFile &log_file : log_files_) {
      for (const LogParts &part : log_file.parts) {
        if (part.node == node_name && part.boot_count == boot_count) {
          result.emplace_back(part);
        }
      }
    }
    return SelectedLogParts(log_source_, node_name, boot_count, result);
  }

  // It provides access to boots of the first element. I'm not sure why...
  const auto &front_boots() const { return log_files_.front().boots; }

  // Access the configuration shared with all log files in the container.
  const Configuration *config() const {
    // TODO (Alexei): it is a first usage of assumption that all parts have
    // matching configs. Should it be strong requirement and validated in the
    // constructor?
    CHECK(configs_matched_);
    return log_files_.front().config.get();
  }

  // List of logger nodes for given set of log files.
  const auto &logger_nodes() const { return logger_nodes_; }

  // TODO (Alexei): it is not clear what it represents for multiple log events.
  // Review its usage.
  std::string_view name() const { return log_files_[0].name; }

 private:
  LogFilesContainer(std::optional<const LogSource *> log_source,
                    std::vector<LogFile> log_files)
      : log_source_(log_source), log_files_(std::move(log_files)) {
    CHECK_GT(log_files_.size(), 0u);

    std::unordered_set<std::string> logger_nodes;

    // Scan and collect all related nodes and number of reboots per node.
    for (const LogFile &log_file : log_files_) {
      for (const LogParts &part : log_file.parts) {
        auto node_item = nodes_boots_.find(part.node);
        if (node_item != nodes_boots_.end()) {
          node_item->second = std::max(node_item->second, part.boot_count + 1);
        } else {
          nodes_boots_[part.node] = part.boot_count + 1;
        }
      }
      logger_nodes.insert(log_file.logger_node);
    }
    while (!logger_nodes.empty()) {
      logger_nodes_.emplace_back(
          logger_nodes.extract(logger_nodes.begin()).value());
    }
    configs_matched_ = CheckMatchingConfigs(log_files_);
  }

  std::optional<const LogSource *> log_source_;
  std::vector<LogFile> log_files_;

  // Keeps information about nodes and number of reboots per node.
  std::unordered_map<std::string, size_t> nodes_boots_;
  std::vector<std::string> logger_nodes_;

  // Indicates that all parts shared the same config.
  bool configs_matched_;
};

}  // namespace logger
}  // namespace aos

#endif  // AOS_EVENTS_LOGGING_LOGFILE_SORTING_H_
